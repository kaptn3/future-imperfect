---
layout: post
title:  "Learn Git. How to Backtrack. Codecademy на русском"
date:   2017-06-04 13:47
category: [Codecademy]
icon: git
link: codecademy
keywords: codecademy, перевод, курс, git
---

<h2>Содержание:</h2>
<ol>
	<li><a href="#intr">Backtracking Intro</a></li>
	<li><a href="#head">Head Commit</a></li>
	<li><a href="#check">Git Checkout</a></li>
	<li><a href="#add">More Git Add</a></li>
	<li><a href="#reset1">Git Reset I</a></li>
	<li><a href="#reset2">Git Reset II</a></li>
	<li><a href="#reset">Git Reset Review</a></li>
	<li><a href="#res">Итоги</a></li>
</ol>
<h2 id="intr">Backtracking Intro</h2>
<p>При работе с git-ом иногда возникает потребность откатить изменения, вернуться назад. Git предлагает нам несколько функций, которые позволяют нам устранить ошибки во время работы с проектом. В этом уроке мы изучим некоторые из них.</p>
<p>Чтобы начать, давайте рассмотрим основную работу с Git.</p>
<h3>Инструкции:</h3>
<ol>
	<li>У вас есть Git-проект под названием <b>hamlet-prince-of-denmark</b>. В редакторе кода вы должны работать с <b>scene-5.txt</b>. Там Гамлет встречает призрака отца. Добавьте следующий текст: <code>Ghost: 
My hour is almost come,
When I to sulphurous and tormenting flames
Must render up myself.</code></li>
	<li>Через терминал проиндексируйте файл <b>scene-5.txt</b></li>
	<li>Закоммитьте изменения в репозиторий с хорошим коммит-сообщением.</li>
</ol>
<h2 id="head">Head Commit</h2>
<p>В Git-е коммит, в котором вы находитесь в настоящее время, известен как <code>HEAD</code>-коммит. В большинстве случаев, <code>HEAD</code>-коммит является последним коммитом.</p>
<p>Чтобы узнать <code>HEAD</code>-коммит, наберите <code>git show HEAD</code></p>
<p>В результате данной команды покажется лог для <code>HEAD</code>-коммита, а также изменения, которые были закомитчены.</p>
<h3>Инструкции:</h3>
<ol>
	<li>Наберите команду, показывающий <code>HEAD</code>-коммит. Обратите внимание на выходные данные - последние добавленные слова Призрака (Ghost) в файле отмечен зелённым цветом.</li>
</ol>
<h2 id="check">Git Checkout</h2>
<p>А что если мы сделали изменения в файл (добавили линии) в рабочей директории, но потом решили отменить эти изменения?</p>
<p>Вы могли бы переписать эти строки, как было изначально, но что если вы забыли как было изначально? Команда <code>git checkout HEAD filename</code> может восстановить файл в рабочем каталоге так, как он выглядел до того, как Вы сделали коммит.</p>
<p>Здесь filename это название файла, который мы хотим восстановить. Если файл назывался бы <b>changes.txt</b>, то команда выглядела бы так: <code>git checkout HEAD changes.txt</code></p>
<h3>Инструкции:</h3>
<ol>
	<li>В этот раз заменим слова. Вот забавное предложение: <code>Ghost: 
My hour is almost come,
When I to sulphurous and tormenting balloons
Must render up myself.</code> [Забавность в следующем - Призрак говорил: Уж близок час мой, Когда в мучительный и серный пламень Вернуться должен я. <br> Теперь же мы заменили слово пламень на воздушный шар (budums)]</li>
	<li>В терминале используя команду <code>git diff</code> посмотрите различия между рабочим каталогом и последним коммитом. Чтобы выйти из диалога diff нажмите <code>q</code>.</li>
	<li>Исползуя новоизученную Git-команду восстановите файл в рабочем каталоге так, как он выглядел в последнем коммите. Обратите внимание, что те изменения слов Призрака, которые вы сделали в сбросятся.</li>
</ol>
<h2 id="add">More Git Add</h2>
<p>В проекте Гамлета мы работаем с пятью файлами. В Git-е можно изменять много файлов, индексировать их и добавлять в один коммит.</p>
<p>Например, скажем, вы захотели поменять героя "ЛАРРИ("LARRY") на "ЛАЭРТ"("LAERTES") в сценарии. Сейчас это имя используется в двух файлах. После того, как вы поменяли это имя в обоих файлах, вы сможете проиндексировать их с помощью команды: <code>git add filename_1 filename_2</code>. Заметьте, что слово filename ссылается на имя файла, который вы хотите проиндексировать.</p>
<h3>Инструкции:</h3>
<ol>
	<li>В редакторе откройте два файла: <b>scene-3.txt</b> и <b>scene-7.txt</b>. В <b>scene-3.txt</b> везде замените "LARRY" на "LAERTES".</li>
	<li>То же самое сделайте и в <b>scene-7.txt</b>.</li>
	<li>Проиндексируйте оба файла используя одну git-команду.</li>
</ol>
<h2 id="reset1">Git Reset II</h2>
<p>Отлично! Файлы проиндексированы и принадлежат одному коммиту.</p>
<p>Что если до того как мы сделаем коммит, мы случайно удалим <b>scene-2.txt</b>?</p>
<p>Будет довольно глупо индексировать <b>scene-2.txt</b>, так как он <i>не связан </i> с заменой Larry/Laertes и его не хочется включать в наш коммит.</p>
<p>Мы можем <i>отменить индексирование файла</i> используя команду <code>git reset HEAD filename</code></p>
<p>Данная команда <i>сбрасывает</i> файл из индекса, чтобы оставаться в <code>HEAD</code>-коммите. Это не значит что изменения файла сбрасываются, просто файл удаляется из индекса.</p>
<h3>Инструкции:</h3>
<ol>
	<li>Чтобы попробовать эту комманду, давайте сделаем ошибку нарочно!<br>
	В редакторе кода откройте <b>scene-2.txt</b>. Удалите какую-нибудь строчку и нажмите Run.</li>
	<li>Через терминал проиндексируйте файл <b>scene-2.txt</b>.</li>
	<li>Проверьте статус Git-проекта. В результате мы увидим сообщение <b>scene-2.txt</b> “Changes to be committed”. Т.е. изменения в файле должны быть закоммитчены.</li>
	<li>Используя новую Git-комманду <i>сбросьте из индекса</i> файл <b>scene-2.txt</b>. Обратите внимание на выходные данные "Unstaged changes after reset" (не индексированные изменения после сброса):<br>
	<code>M scene-2.txt</code>
	<ul>
		<li><code>M</code> - это коротко "modification"(изменение).</li>
	</ul></li>
	<li>Теперь изменения в <b>scene-2.txt</b> снова не проиндексированы и теперь всё готово, чтобы сделать коммит. Через терминал сделайте коммит, чтобы сохранить замену Larry/Laertes в репозитории <b>hamlet</b>.</li>
</ol>
<h2 id="reset1">Git Reset I</h2>
<p>Создание проекта - это как поход в тёмный лес. Иногда Вы неверно поворачиваете, затем снова неверно поворачиваете. Затем вы узнаёте, что окружены медведями.</p>
<p>Git позволяет нам "перемотать" до того места, где вы сделали неверный поворот и создать новый путь вашего проекта. Это можно сделать с помощью команды <code>git reset SHA</code></p>
<p>Это команда работает с первыми семью символами SHA предыдущего коммита. Например, если SHA предыдущего коммита <code>5d692065cf51a2f50ea8e7b19b5a7ae512f633ba</code>, то команда будет выглядить так: <code>git reset 5d69206</code></p>
<h3>Инструкции:</h3>
<ol>
	<li>Через терминал узнайте историю коммитов. <b>Примечание:</b> если курсор мигает, то есть вы находитесь в git-log mode, нажмите <code>q</code>, чтобы выйти из него.</li>
	<li>Через терминал наберите команду <code>reset</code> к предыдущему коммиту, используя первые семь символов последнего коммита из логов.<br>
	Теперь снова посмотрите логи коммитов.<br>
	Заметили что-нибудь интересного? Коммиты, которые мы сбросили, пропали. Теперь <code>HEAD</code>-коммит переназначен. Вы просто изменили историю.</li>
</ol>
<h2 id="reset">Git Reset Review</h2>
<p>Чтобы лучше понять <code>git reset commit_SHA</code>, посмотрите на диараму справа. Каждый кружок означает коммит.</p>
<h4>До сброса:</h4>
<ul>
	<li><code>HEAD</code> - это <i>последний коммит</i>.</li>
</ul>
<h4>После сброса:</h4>
<ul>
	<li><code>HEAD</code> переходит на <i>предыдущий коммит</i> вашего выбора</li>
	<li>Серые коммиты больше не являются частью вашего проекта</li>
	<li>С сущности вы <i>перематываете</i> историю вашего проекта</li>
</ul>
<h2 id="res">Итоги</h2>
<p>Наши поздравления! Вы изучили три разных способа отката в Git-е. Вы можете использовать эти навыки, чтобы отменить изменения, внесённые в Git-проект.</p>
<p>Воспользуемся моментом, и рассмотрим изученные команды:
	<ul>
		<li><code>git checkout HEAD filename</code>: отменяет изменения, сделанные в рабочем каталоге.</li>
		<li><code>git reset HEAD filename</code>: сбрасывает файл из индекса.</li>
		<li><code>git reset SHA</code>: сброс до предыдущего коммита в вашей коммит-истории.</li>
	</ul>
</p>
Дополнительно, вы изучили как индексировать сразу несколько файлов с помощью команды:
<code>git add filename_1 filename_2</code>